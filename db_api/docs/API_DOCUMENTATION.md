# Fase 0: 

Integraci√≥n Backend Django + Frontend React - Ana Prevention**Fecha:** 10 Febrero 2026**Contexto:** Sistema SaaS multi-tenant para cl√≠nicas ocupacionales con Django backend + Next.js frontend---

## üìã Tabla de Contenidos1. [Decisiones Arquitect√≥nicas](#decisiones-arquitect√≥nicas)2. [Fase 0: Setup Autenticaci√≥n](#fase-0-setup-autenticaci√≥n)3. [Arquitectura AWS Multi-tenant](#arquitectura-aws-multi-tenant)4. [Validaci√≥n de Subdominios](#validaci√≥n-de-subdominios)5. [Pr√≥ximos Pasos](#pr√≥ximos-pasos)---## üéØ Decisiones Arquitect√≥nicas### **1. Sistema de Autenticaci√≥n: Django Auth (TENANT model)****Decisi√≥n:** Usar Django Auth nativo en lugar de Better Auth o Firebase Auth**Razones:**- ‚úÖ **578 usuarios legacy** existentes en MySQL con hashes ASP.NET Identity- ‚úÖ **Migraci√≥n m√°s directa** a Django que a Better Auth- ‚úÖ **Django Admin** funciona out-of-the-box- ‚úÖ **Permissions/Groups** nativos de Django- ‚úÖ **Menos complejidad** (un solo sistema vs. sincronizar Better Auth + Django)- ‚úÖ **Madurez** (Django Auth tiene 18 a√±os de desarrollo)**Alternativas consideradas:**- ‚ùå Better Auth: Agregar√≠a complejidad de sincronizaci√≥n, requiere mantener dos sistemas- ‚ùå Firebase Auth: Dependencia externa, costos recurrentes, vendor lock-in### **2. Multi-tenancy: TENANT Model (Users por Schema)****Decisi√≥n:** Users en schema TENANT (no SHARED)**Modelo Legacy:**```sqlsecurity_users‚îú‚îÄ‚îÄ company_id (FK directa a UNA company)‚îî‚îÄ‚îÄ Un user = Un tenant```**Implementaci√≥n Django:**```pythonTENANT_APPS = [    'django.contrib.auth',  # ‚Üê Auth en TENANT    'personnel',  # SystemUser aqu√≠    'core',    'forms',    'protocols',]```**Razones:**- ‚úÖ **Consistencia con legacy** (578 usuarios siguen este patr√≥n)- ‚úÖ **Aislamiento total** por tenant (mayor seguridad m√©dica)- ‚úÖ **Simplicidad** (un usuario pertenece a UN tenant)**Nota:** Si en el futuro se necesita que un usuario acceda a m√∫ltiples tenants, se puede migrar a SHARED model.### **3. Arquitectura de Dominios: Wildcard DNS + CloudFront****Decisi√≥n:** Cada tenant tiene su propio subdominio**Ejemplos:**```clinica-lima.anaprevention.comclinica-arequipa.anaprevention.comminera-abc.anaprevention.com```**Razones:**- ‚úÖ **Branding** profesional para cada cliente- ‚úÖ **Compliance m√©dico** (aislamiento visual claro)- ‚úÖ **Escalable** (wildcard DNS cubre infinitos subdominios)- ‚úÖ **Sin configuraci√≥n por tenant** (wildcard autom√°tico)---## üîê Fase 0: Setup Autenticaci√≥n### **Backend: Django + JWT**#### **1. Dependencias**```bashcd db_apipip install djangorestframework-simplejwt django-cors-headerspip freeze > requirements.txt```#### **2. Settings Configuration**```python# config/settings.pyINSTALLED_APPS = [    'rest_framework',    'rest_framework_simplejwt',    'rest_framework_simplejwt.token_blacklist',    'corsheaders',    # ... existing apps]MIDDLEWARE = [    'corsheaders.middleware.CorsMiddleware',  # ANTES de CommonMiddleware    'core.middleware.ValidateTenantMiddleware',  # Custom (ver abajo)    'django.middleware.security.SecurityMiddleware',    # ... resto]# Auth en TENANT_APPS (cada company tiene sus users)SHARED_APPS = [    'django_tenants',    'tenants',    'utils',    'django.contrib.contenttypes',    'django.contrib.sessions',]TENANT_APPS = [    'django.contrib.auth',  # ‚Üê AUTH EN TENANT    'rest_framework',    'rest_framework_simplejwt',    'personnel',    'core',    'forms',    'protocols',]# JWT ConfigurationREST_FRAMEWORK = {    'DEFAULT_AUTHENTICATION_CLASSES': [        'rest_framework_simplejwt.authentication.JWTAuthentication',    ],}SIMPLE_JWT = {    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),    'ROTATE_REFRESH_TOKENS': True,    'BLACKLIST_AFTER_ROTATION': True,    'ALGORITHM': 'HS256',}# CORSCORS_ALLOWED_ORIGINS = [    "http://localhost:3000",    "https://*.anaprevention.com",  # Wildcard para subdominios]CORS_ALLOW_CREDENTIALS = True```#### **3. Modelo SystemUser**```python# personnel/models/system_user.pyfrom django.contrib.auth.models import Userfrom django.db import modelsimport uuidclass SystemUser(models.Model):    """Usuario del sistema (staff: admins, doctores, enfermeras)"""    id = models.UUIDField(primary_key=True, default=uuid.uuid4)        # Django User (auth)    user = models.OneToOneField(        User,        on_delete=models.CASCADE,        related_name='system_user'    )        # Relaci√≥n con Person (si es staff cl√≠nico)    person = models.OneToOneField(        'personnel.Person',        null=True,        blank=True,        on_delete=models.SET_NULL,        related_name='system_user'    )        # Tipo de usuario    user_type = models.CharField(        max_length=100,        choices=[            ('admin', 'Administrador'),            ('doctor', 'M√©dico Ocupacional'),            ('nurse', 'Enfermera'),            ('operator', 'Operador'),            ('digitizer', 'Digitaci√≥n'),            ('auditor', 'Auditor'),        ]    )        # Settings    settings_json = models.JSONField(default=dict, blank=True)        # Control    is_approved = models.BooleanField(default=False)    is_blocked = models.BooleanField(default=False)    request_change_password = models.BooleanField(default=False)        # Migraci√≥n legacy    legacy_id = models.UUIDField(null=True, blank=True)        # Auditor√≠a    created_at = models.DateTimeField(auto_now_add=True)    updated_at = models.DateTimeField(auto_now=True)        class Meta:        db_table = 'personnel_system_user'```#### **4. Endpoints de Autenticaci√≥n**```python# personnel/endpoints/auth.pyfrom ninja import Routerfrom rest_framework_simplejwt.tokens import RefreshTokenfrom django.contrib.auth import authenticaterouter = Router(tags=["Authentication"])@router.post("/login", auth=None)def login(request, username: str, password: str, tenant_id: str = None):    """    Login con tenant espec√≠fico (TENANT model requiere saber tenant antes)        Si tenant_id no se proporciona, usar el domain del request.    """    hostname = request.get_host()        # Setear tenant desde domain o tenant_id    if tenant_id:        tenant = Tenant.objects.get(id=tenant_id)    else:        domain = Domain.objects.get(domain=hostname)        tenant = domain.tenant        connection.set_tenant(tenant)        # Autenticar en el schema del tenant    user = authenticate(request, username=username, password=password)        if not user:        raise HttpError(401, "Credenciales inv√°lidas")        # Validar SystemUser    try:        system_user = user.system_user    except SystemUser.DoesNotExist:        raise HttpError(403, "Usuario no autorizado")        if system_user.is_blocked:        raise HttpError(403, "Usuario bloqueado")        if not system_user.is_approved:        raise HttpError(403, "Usuario pendiente de aprobaci√≥n")        # Generar JWT    refresh = RefreshToken.for_user(user)    refresh['tenant_id'] = str(tenant.id)  # Custom claim        return {        "access": str(refresh.access_token),        "refresh": str(refresh),        "user": {            "id": str(system_user.id),            "username": user.username,            "email": user.email,            "user_type": system_user.user_type,        },        "tenant": {            "id": str(tenant.id),            "name": tenant.name,        }    }@router.post("/refresh", auth=None)def refresh_token(request, refresh: str):    """Refresh access token"""    from rest_framework_simplejwt.tokens import RefreshToken        try:        refresh_token = RefreshToken(refresh)        return {"access": str(refresh_token.access_token)}    except Exception:        raise HttpError(401, "Token inv√°lido")@router.get("/me", auth=JWTAuth())def get_current_user(request):    """Obtiene usuario autenticado"""    system_user = request.user.system_user        return {        "id": str(system_user.id),        "username": request.user.username,        "email": request.user.email,        "user_type": system_user.user_type,        "settings": system_user.settings_json,    }@router.post("/logout", auth=JWTAuth())def logout(request):    """Logout (blacklist token)"""    return {"message": "Logout exitoso"}```#### **5. Middleware de Validaci√≥n de Tenant**```python# core/middleware.pyfrom django.http import HttpResponsefrom django_tenants.utils import get_tenant_domain_modelfrom django.db import connectionclass ValidateTenantMiddleware:    """    Valida que el domain existe y est√° activo.    Retorna 404 HTML si no existe.    """        def __init__(self, get_response):        self.get_response = get_response        def __call__(self, request):        hostname = request.get_host()        Domain = get_tenant_domain_model()                try:            domain = Domain.objects.select_related('tenant').get(domain=hostname)            tenant = domain.tenant                        # Setear schema            connection.set_tenant(tenant)            request.tenant = tenant                    except Domain.DoesNotExist:            # Domain no existe - retornar 404            return self.render_404(hostname)                return self.get_response(request)        def render_404(self, hostname):        html = f"""        <!DOCTYPE html>        <html>        <head><title>Organizaci√≥n no encontrada</title></head>        <body style="font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center;">            <h1>üîç Organizaci√≥n no encontrada</h1>            <p>El subdominio <strong>{hostname}</strong> no existe.</p>            <a href="https://anaprevention.com">‚Üê Volver al inicio</a>        </body>        </html>        """        return HttpResponse(html, status=404)```### **Frontend: Next.js + JWT**#### **1. Django Auth Client**```typescript// src/lib/auth/django-client.tsimport axios from 'axios';interface LoginCredentials {  username: string;  password: string;}interface LoginResponse {  access: string;  refresh: string;  user: {    id: string;    username: string;    email: string;    user_type: string;  };  tenant: {    id: string;    name: string;  };}class DjangoAuthClient {  private baseURL = process.env.NEXT_PUBLIC_DJANGO_API || 'http://localhost:8000';  async login(credentials: LoginCredentials): Promise<LoginResponse> {    const response = await axios.post(      `${this.baseURL}/api/personnel/auth/login`,      credentials    );        const data = response.data;    this.setTokens(data.access, data.refresh);        return data;  }  async refresh(): Promise<string> {    const refreshToken = this.getRefreshToken();    if (!refreshToken) throw new Error('No refresh token');    const response = await axios.post(      `${this.baseURL}/api/personnel/auth/refresh`,      { refresh: refreshToken }    );    const { access } = response.data;    this.setAccessToken(access);    return access;  }  async getCurrentUser() {    const token = this.getAccessToken();    const response = await axios.get(      `${this.baseURL}/api/personnel/auth/me`,      { headers: { Authorization: `Bearer ${token}` } }    );    return response.data;  }  async logout() {    const token = this.getAccessToken();    await axios.post(      `${this.baseURL}/api/personnel/auth/logout`,      {},      { headers: { Authorization: `Bearer ${token}` } }    );    this.clearTokens();  }  private setTokens(access: string, refresh: string) {    localStorage.setItem('django_access_token', access);    localStorage.setItem('django_refresh_token', refresh);  }  private setAccessToken(access: string) {    localStorage.setItem('django_access_token', access);  }  getAccessToken(): string | null {    return localStorage.getItem('django_access_token');  }  private getRefreshToken(): string | null {    return localStorage.getItem('django_refresh_token');  }  private clearTokens() {    localStorage.removeItem('django_access_token');    localStorage.removeItem('django_refresh_token');  }  isAuthenticated(): boolean {    return !!this.getAccessToken();  }}export const djangoAuth = new DjangoAuthClient();```#### **2. API Client con Interceptores**```typescript// src/lib/api-client.tsimport axios from 'axios';import { djangoAuth } from './auth/django-client';export const apiClient = axios.create({  baseURL: process.env.NEXT_PUBLIC_DJANGO_API || 'http://localhost:8000',});// Request interceptor - agregar JWTapiClient.interceptors.request.use(  (config) => {    const token = djangoAuth.getAccessToken();    if (token) {      config.headers.Authorization = `Bearer ${token}`;    }    return config;  },  (error) => Promise.reject(error));// Response interceptor - auto refreshapiClient.interceptors.response.use(  (response) => response,  async (error) => {    const originalRequest = error.config;    if (error.response?.status === 401 && !originalRequest._retry) {      originalRequest._retry = true;      try {        const newToken = await djangoAuth.refresh();        originalRequest.headers.Authorization = `Bearer ${newToken}`;        return apiClient(originalRequest);      } catch (refreshError) {        djangoAuth.clearTokens();        window.location.href = '/ingreso';        return Promise.reject(refreshError);      }    }    return Promise.reject(error);  });```#### **3. Auth Context**```typescript// src/core/context/DjangoAuthContext.tsximport { createContext, useContext, useState, useEffect } from 'react';import { djangoAuth } from '@/lib/auth/django-client';interface User {  id: string;  username: string;  email: string;  user_type: string;}interface AuthContextType {  user: User | null;  loading: boolean;  login: (username: string, password: string) => Promise<void>;  logout: () => Promise<void>;  isAuthenticated: boolean;}const DjangoAuthContext = createContext<AuthContextType | undefined>(undefined);export function DjangoAuthProvider({ children }) {  const [user, setUser] = useState<User | null>(null);  const [loading, setLoading] = useState(true);  useEffect(() => {    loadUser();  }, []);  async function loadUser() {    if (djangoAuth.isAuthenticated()) {      try {        const userData = await djangoAuth.getCurrentUser();        setUser(userData);      } catch (error) {        djangoAuth.clearTokens();      }    }    setLoading(false);  }  async function login(username: string, password: string) {    const response = await djangoAuth.login({ username, password });    setUser(response.user);  }  async function logout() {    await djangoAuth.logout();    setUser(null);  }  return (    <DjangoAuthContext.Provider value={{ user, loading, login, logout, isAuthenticated: !!user }}>      {children}    </DjangoAuthContext.Provider>  );}export function useDjangoAuth() {  const context = useContext(DjangoAuthContext);  if (!context) throw new Error('useDjangoAuth must be used within DjangoAuthProvider');  return context;}```---## üåê Arquitectura AWS Multi-tenant### **Infraestructura Completa**```Internet  ‚ÜìRoute 53: *.anaprevention.com ‚Üí CloudFront  ‚ÜìCloudFront Distribution  ‚îú‚îÄ Origin 1: S3 (Frontend Next.js)  ‚îî‚îÄ Origin 2: ALB (Backend Django)       ‚Üì       ECS Fargate (Django x3)       ‚Üì       RDS PostgreSQL (Multi-schema)```### **1. Route 53 - DNS Wildcard****Configuraci√≥n (una sola vez):**```bash# Hosted Zone: anaprevention.com# Record:Name: *.anaprevention.comType: A (Alias)Value: CloudFront distribution (d123.cloudfront.net)```**Resultado:** TODOS los subdominios resuelven a CloudFront autom√°ticamente:- clinica-lima.anaprevention.com ‚Üí CloudFront ‚úÖ- clinica-arequipa.anaprevention.com ‚Üí CloudFront ‚úÖ- nuevo-cliente.anaprevention.com ‚Üí CloudFront ‚úÖ**NO necesitas crear DNS por cada cliente** (wildcard lo cubre todo)### **2. Certificate Manager - SSL Wildcard**```bash# Request en us-east-1 (requerido por CloudFront)Domain: *.anaprevention.comValidation: DNS (autom√°tico con Route 53)```**Un certificado cubre infinitos subdominios**### **3. CloudFront - Routing**```javascript// CloudFront OriginsOrigins: [  {    Id: "S3-Frontend",    Domain: "anaprevention-frontend.s3.amazonaws.com"  },  {    Id: "ALB-Backend",    Domain: "anaprevention-alb.us-east-1.elb.amazonaws.com"  }]// BehaviorsDefaultBehavior: {  TargetOrigin: "S3-Frontend",  // Frontend por defecto  ViewerProtocolPolicy: "redirect-to-https"}CacheBehaviors: [  {    PathPattern: "/api/*",    TargetOrigin: "ALB-Backend",  // API requests a Django    ForwardedHeaders: ["Host", "Authorization"],    MinTTL: 0  // No cache para API  }]```**Flujo:**- `https://clinica-lima.anaprevention.com/` ‚Üí S3 (Frontend)- `https://clinica-lima.anaprevention.com/api/businesses` ‚Üí ALB ‚Üí Django### **4. Onboarding Nuevo Cliente****Script autom√°tico (Django):**```python# tenants/services/onboarding.pydef create_new_tenant(data):    # 1. Crear Company (crea schema PostgreSQL autom√°ticamente)    company = Company.objects.create(        schema_name=f"company_{data['slug']}",        name=data['name'],    )    # ‚Üí PostgreSQL: CREATE SCHEMA company_clinica_lima;        # 2. Crear Domain (SOLO en Django DB)    domain = Domain.objects.create(        domain=f"{data['slug']}.anaprevention.com",        tenant=company,        is_primary=True,    )    # ‚Üí NO toca AWS, wildcard DNS ya cubre este subdominio        # 3. Crear admin user en schema del tenant    connection.set_tenant(company)    admin_user = User.objects.create_user(...)    SystemUser.objects.create(user=admin_user, user_type='admin')        return domain.domain  # "clinica-lima.anaprevention.com"```**Total time:** ~10 segundos**El nuevo subdominio funciona INMEDIATAMENTE:**- ‚úÖ DNS: wildcard ya configurado- ‚úÖ SSL: certificado wildcard ya v√°lido- ‚úÖ CloudFront: acepta el subdominio- ‚úÖ Django: schema creado### **Costos Estimados**| Servicio | Specs | Costo/mes ||----------|-------|-----------|| Route 53 | Hosted zone + queries | $1 || ACM | Wildcard SSL | $0 (gratis) || CloudFront | 1TB transfer | $85 || S3 | Frontend storage | $1 || ECS Fargate | 3 tasks (1 vCPU, 2GB) | $90 || ALB | Load balancer | $25 || RDS PostgreSQL | db.t3.medium | $60 || **Total** | 50 tenants | **~$262/mes** || **Por tenant** | | **$5.24/mes** |---## ‚úÖ Validaci√≥n de Subdominios### **Problema:** Wildcard permite subdominios inexistentesCon wildcard DNS, CUALQUIER subdominio carga:- ‚úÖ clinica-lima.anaprevention.com (v√°lido)- ‚ùå typo-clinica.anaprevention.com (NO existe en DB)- ‚ùå random123.anaprevention.com (NO existe)### **Soluci√≥n: Frontend Ping + Backend Validation**#### **Backend: Endpoint de Validaci√≥n**```python# tenants/endpoints/validation.pyfrom ninja import Routerfrom django_tenants.utils import get_tenant_domain_modelrouter = Router(tags=["Validation"])@router.get("/validate", auth=None)def validate_domain(request):    """Valida que el domain del request existe"""    hostname = request.get_host()    Domain = get_tenant_domain_model()        try:        domain = Domain.objects.select_related('tenant').get(domain=hostname)                return {            "valid": True,            "tenant": {                "id": str(domain.tenant.id),                "name": domain.tenant.name,            }        }            except Domain.DoesNotExist:        # Buscar sugerencias (typo correction)        from difflib import get_close_matches        all_domains = list(Domain.objects.values_list('domain', flat=True))        suggestions = get_close_matches(hostname, all_domains, n=3, cutoff=0.6)                return {            "valid": False,            "reason": "not_found",            "message": f"La organizaci√≥n {hostname} no existe",            "suggestions": suggestions        }```#### **Frontend: Validador Component**```typescript// src/components/TenantValidator.tsx'use client';import { useEffect, useState } from 'react';export function TenantValidator({ children }) {  const [status, setStatus] = useState<'loading' | 'valid' | 'invalid'>('loading');  const [data, setData] = useState(null);  useEffect(() => {    validateDomain();  }, []);  async function validateDomain() {    try {      const response = await fetch('/api/tenants/validate');      const result = await response.json();      if (result.valid) {        // Cache resultado por 1 hora        localStorage.setItem('tenant_validated', 'true');        localStorage.setItem('tenant_validated_at', Date.now().toString());        setStatus('valid');      } else {        setData(result);        setStatus('invalid');      }    } catch (error) {      setStatus('invalid');    }  }  if (status === 'loading') {    return <div>Verificando organizaci√≥n...</div>;  }  if (status === 'invalid') {    return (      <div style={{ maxWidth: '600px', margin: '100px auto', textAlign: 'center' }}>        <h1>üîç Organizaci√≥n no encontrada</h1>        <p>{data?.message}</p>        {data?.suggestions && (          <div>            <p>¬øQuisiste decir:</p>            {data.suggestions.map(s => (              <a key={s} href={`https://${s}`}>{s}</a>            ))}          </div>        )}        <a href="https://anaprevention.com">‚Üê Volver al inicio</a>      </div>    );  }  return children;}``````typescript// src/app/layout.tsximport { TenantValidator } from '@/components/TenantValidator';export default function RootLayout({ children }) {  return (    <html>      <body>        <TenantValidator>          {children}        </TenantValidator>      </body>    </html>  );}```**Flujo:**1. Usuario accede: `typo-clinica.anaprevention.com`2. CloudFront sirve frontend HTML/JS3. Frontend ejecuta `fetch('/api/tenants/validate')`4. Django valida ‚Üí Domain no existe ‚Üí 4045. Frontend muestra p√°gina de error con sugerencias**Performance:**- Validaci√≥n: ~50ms- Cache: 1 hora (no valida en cada navegaci√≥n)- UX: Loading imperceptible---## üöÄ Pr√≥ximos Pasos### **Implementaci√≥n Inmediata****Backend:**1. ‚úÖ Crear modelo `SystemUser` en `personnel/models/system_user.py`2. ‚úÖ Crear endpoints auth en `personnel/endpoints/auth.py`3. ‚úÖ Crear endpoint validaci√≥n en `tenants/endpoints/validation.py`4. ‚úÖ Configurar `settings.py` (JWT, CORS, TENANT_APPS)5. ‚úÖ Crear middleware `ValidateTenantMiddleware`6. ‚úÖ Run migrations7. ‚úÖ Crear usuario de prueba**Frontend:**1. ‚úÖ Crear `DjangoAuthClient` en `src/lib/auth/django-client.ts`2. ‚úÖ Crear `apiClient` con interceptores en `src/lib/api-client.ts`3. ‚úÖ Crear `DjangoAuthContext` en `src/core/context/DjangoAuthContext.tsx`4. ‚úÖ Crear `TenantValidator` en `src/components/TenantValidator.tsx`5. ‚úÖ Actualizar `app/layout.tsx`6. ‚úÖ Crear p√°gina de login en `app/ingreso/page.tsx`**AWS (una sola vez):**1. ‚úÖ Configurar Route 53 wildcard: `*.anaprevention.com`2. ‚úÖ Request SSL wildcard en ACM3. ‚úÖ Deploy Django a ECS4. ‚úÖ Deploy Next.js a S35. ‚úÖ Configurar CloudFront### **Testing****Validar funcionamiento:**```bash# 1. Crear tenant de pruebacurl -X POST http://localhost:8000/api/tenants/signup \  -H "Content-Type: application/json" \  -d '{    "name": "Cl√≠nica Test",    "slug": "clinica-test",    "admin_email": "admin@test.com",    "password": "test123"  }'# 2. Validar domaincurl https://clinica-test.anaprevention.com/api/tenants/validate# 3. Logincurl -X POST https://clinica-test.anaprevention.com/api/personnel/auth/login \  -H "Content-Type: application/json" \  -d '{"username": "admin@test.com", "password": "test123"}'# 4. Probar subdominio inv√°lidocurl https://random123.anaprevention.com/api/tenants/validate# ‚Üí {"valid": false, "reason": "not_found"}```### **Migraci√≥n de 578 Usuarios Legacy**```python# management/commands/migrate_legacy_users.pyfrom django.core.management.base import BaseCommandfrom django.contrib.auth.models import Userfrom personnel.models import SystemUserimport pymysqlclass Command(BaseCommand):    def handle(self, *args, **options):        # 1. Conectar a legacy MySQL        legacy_db = pymysql.connect(host='legacy-host', ...)        cursor = legacy_db.cursor()                # 2. Obtener usuarios activos        cursor.execute("""            SELECT u.id, u.user_name, u.password, u.full_name,                    u.company_id, ut.description as user_type            FROM security_users u            JOIN security_user_types ut ON u.user_type_id = ut.id            WHERE u.status = 1        """)                for legacy_user in cursor.fetchall():            # 3. Para cada company, setear tenant y crear user            tenant = Tenant.objects.get(legacy_id=legacy_user['company_id'])            connection.set_tenant(tenant)                        # 4. Crear Django User            user = User.objects.create_user(                username=legacy_user['user_name'],                email=legacy_user['user_name'],            )                        # 5. Guardar hash legacy (temporal)            user.password = f"aspnet_identity${legacy_user['password']}"            user.save()                        # 6. Crear SystemUser            SystemUser.objects.create(                user=user,                user_type=map_user_type(legacy_user['user_type']),                legacy_id=legacy_user['id'],                is_approved=True            )                print(f"Migrated {cursor.rowcount} users")```---## üìö Documentos Relacionados- `ANALISIS_REPOSITORIOS.md` - An√°lisis completo de backend y frontend- `PLAN_INTEGRACION_ENDPOINTS.md` - Plan de integraci√≥n de 16 semanas- `INFORME_BETTER_AUTH.md` - An√°lisis de Better Auth vs Django Auth## üéØ Resumen Ejecutivo**Decisiones clave:**- ‚úÖ Django Auth TENANT model (no Better Auth, no Firebase)- ‚úÖ JWT con SimpleJWT- ‚úÖ Multi-tenancy por subdomain (wildcard DNS)- ‚úÖ Validaci√≥n de subdominios en frontend (ping)- ‚úÖ Arquitectura AWS escalable**Tiempo estimado Fase 0:** 2 semanas**Costo AWS:** ~$5/mes por tenant**Estado:** Listo para implementar